--[[
-- THIS VERSION IS MODDED BY TETREX, NOT ORIGINAL.

-- THIS SCRIPT HAS BEEN CODED BY RAFA (discord.gg/MilkUp)
-- DON'T BE A STUPID SKIDDIE THAT STEAL PEOPLE CODE AND PUT ON A SHIT PAID (or "watch ad to get key") SCRIPT
-- hi Project WD please don't steal my code again thx

-- For Preston:
-- Sorry for any incovenience I don't make any malicous script like mail/bank stealers, trade scam and this shit, just auto-farm and QoL scripts, feel free to use this repo to fix any vulnerability on your game
--]]

-- Join us at 
-- discord.gg/MilkUp




--[[
-- TODO LIST:
-- • Huge notifier on Discord Webhook (its ez but I'm lazy)
-- • Auto quest
-- • Improve Bank Index with "Auto buy storage upgrades" (+ withdraw needed diamonds from bank)
--]]


-- Important Variables
local SCRIPT_NAME = "Rafa PSX GUI"
local SCRIPT_VERSION = "v0.4" -- Hey rafa remember to change it before updating lmao

-- Detect if the script has executed by AutoExec
local AutoExecuted = false
if not game:IsLoaded() then AutoExecuted = true end

repeat task.wait() until game.PlaceId ~= nil
if not game:IsLoaded() then
	repeat wait() until game:IsLoaded()
end

--//-------------- SERVICES ----------------//*
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local InputService = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ContentProvider = game:GetService("ContentProvider")

for i,v in pairs(getconnections(game.Players.LocalPlayer.Idled)) do
	v:Disable()
end
setfpscap(10)

local Whitelist = {
	"iTetreX",
	"iTwineX",
	"claynight08",
	"ALTERATION27",
	"DIALATORIFIER_858",
	"TOFFEEATOR_779",
	"Chainstayman919",
	"TheLeadinganator650",
	"ADVANTAGEGUY892",
	"MrSafariguy645",
	"Guiltator72",
	"THE_STABGUY585",
	"TheLeadinganator650",
	"HamzaPetKas8",
	"THE_ALPENGLOWMAN980",
	"Creativeguy175",
	"EnchantingSchast",
	"WonderfulGion",
	"Onadnever",
	"AltiverHermano",
	"Offectiouslas",
	"MR_INTUITIONATOR191",
	"TheMareguy_221",
	"ELICITMAN_134",
	"Hellcatanator915",
	"MR_INFARCTIONATOR261",
	"Fertilizerguy_670",
	"MrCorporationman_281",
	"MrMoatator338",
	"MrHorseguy949",
	"MrMochiguy_215",
	"TheLunch857",
	"TheKiwianator56",
	"MR_REGIME737",
	"TheInhabitantman5",
	"MrPerchifier852",
	"TheRifleator334",
	"MrWalnut_124",
	"Poisonatorifier95",
	"MrVeneer193",
	"Forebear231",
	"TheGrandpa70",
	"Bronchitisguy_756",
	"MrGrandmaanator591",
	"Manifestation590",
	"Weekendman_268",
	"Publicationguy881",
	"MrMarksmanator831",
	"Lectureguy757",
	"THE_OLIVEIFIER327",
	"MR_STYLEANATOR676",
	"MrBuilderman963",
	"TheCraneifier_295",
	"Elif_Nur35",
	"THE_GUYGUY76",
	"Oatsman520",
	"MrWoodshedanator751",
	"Inkanator21",
	"THE_HUBCAPIFIER915",
	"Trendanator130",
	"TheRunifier_301",
	"ferhat131ff",
	"MrSpruceanator_841",
	"MR_BACKDROPGUY860",
	"TheLungguy_535",
	"RlympJellybean",
	"Manifestation590",
	"Passinganator767",
	"Heronator_909",
	"LethoHotThing",
	"BedmostMonCoeur",
	"BertPuzzler",
	"GionitTonezone",
	"MyroddGoodDude",
	"MrRamenman421",
	"MrSignalator_210"
}

--//*--------- GLOBAL VARIABLES -----------//*
local ScriptIsCurrentlyBusy = false
local ForceMultiFarm = false
local ForceAutoFarm = false
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local CurrentWorld = ""
local CurrentPosition = nil

local Settings_DisableRendering = false

local Webhook_Enabled = true
local Webhook_URL = "https://discord.com/api/webhooks/1100482719760252958/jwsnNJyJfQ8JvlsupUzCs_jseLqzQOYJp27l5l_hv93xdNZACoNXqkS3SN9U9yFvYqH4"
local Webhook_Daycare = true
local Webhook_Huge = true

LocalPlayer.CharacterAdded:Connect(function(char) 
	Character = char
	Humanoid = Character:WaitForChild("Humanoid")
	HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

if game.PlaceId == 6284583030 or game.PlaceId == 10321372166 then
	
	local banSuccess, banError = pcall(function() 
		local Blunder = require(game:GetService("ReplicatedStorage"):WaitForChild("X", 10):WaitForChild("Blunder", 10):WaitForChild("BlunderList", 10))
		if not Blunder or not Blunder.getAndClear then LocalPlayer:Kick("Error while bypassing the anti-cheat! (Didn't find blunder)") end
		
		local OldGet = Blunder.getAndClear
		setreadonly(Blunder, false)
		local function OutputData(Message)
		   print("-- PET SIM X BLUNDER --")
		   print(Message .. "\n")
		end
		
		Blunder.getAndClear = function(...)
		   local Packet = ...
			for i,v in next, Packet.list do
			   if v.message ~= "PING" then
				   OutputData(v.message)
				   table.remove(Packet.list, i)
			   end
		   end
		   return OldGet(Packet)
		end
		
		setreadonly(Blunder, true)
	end)

	if not banSuccess then
		LocalPlayer:Kick("Error while bypassing the anti-cheat! (".. banError ..")")
		return
	end
	
	local Library = require(game:GetService("ReplicatedStorage").Library)
	assert(Library, "Oopps! Library has not been loaded. Maybe try re-joining?") 
	while not Library.Loaded do task.wait() end

	local AllPets = require(game:GetService("ReplicatedStorage")["__DIRECTORY"].Pets["Grab All Pets"])

	local bypassSuccess, bypassError = pcall(function()
		if not Library.Network then 
			LocalPlayer:Kick("Network not found, can't bypass!")
		end
		
		if not Library.Network.Invoke or not Library.Network.Fire then
			LocalPlayer:Kick("Network Invoke/Fire was not found! Failed to bypass!")
		end
		
		hookfunction(debug.getupvalue(Library.Network.Invoke, 1), function(...) return true end)
		-- Currently we don't need to hook Fire, since both Invoke/Fire have the same upvalue, this may change in future.
		-- hookfunction(debug.getupvalue(Library.Network.Fire, 1), function(...) return true end)
		
		local originalPlay = Library.Audio.Play
		Library.Audio.Play = function(...) 
			if checkcaller() then
				local audioId, parent, pitch, volume, maxDistance, group, looped, timePosition = unpack({ ... })
				if type(audioId) == "table" then
					audioId = audioId[Random.new():NextInteger(1, #audioId)]
				end
				if not parent then
					warn("Parent cannot be nil", debug.traceback())
					return nil
				end
				if audioId == 0 then return nil end
				
				if type(audioId) == "number" or not string.find(audioId, "rbxassetid://", 1, true) then
					audioId = "rbxassetid://" .. audioId
				end
				if pitch and type(pitch) == "table" then
					pitch = Random.new():NextNumber(unpack(pitch))
				end
				if volume and type(volume) == "table" then
					volume = Random.new():NextNumber(unpack(volume))
				end
				if group then
					local soundGroup = game.SoundService:FindFirstChild(group) or nil
				else
					soundGroup = nil
				end
				if timePosition == nil then
					timePosition = 0
				else
					timePosition = timePosition
				end
				local isGargabe = false
				if not pcall(function() local _ = parent.Parent end) then
					local newParent = parent
					pcall(function()
						newParent = CFrame.new(newParent)
					end)
					parent = Instance.new("Part")
					parent.Anchored = true
					parent.CanCollide = false
					parent.CFrame = newParent
					parent.Size = Vector3.new()
					parent.Transparency = 1
					parent.Parent = workspace:WaitForChild("__DEBRIS")
					isGargabe = true
				end
				local sound = Instance.new("Sound")
				sound.SoundId = audioId
				sound.Name = "sound-" .. audioId
				sound.Pitch = pitch and 1
				sound.Volume = volume and 0.5
				sound.SoundGroup = soundGroup
				sound.Looped = looped and false
				sound.MaxDistance = maxDistance and 100
				sound.TimePosition = timePosition
				sound.RollOffMode = Enum.RollOffMode.Linear
				sound.Parent = parent
				if not require(game:GetService("ReplicatedStorage"):WaitForChild("Library"):WaitForChild("Client")).Settings.SoundsEnabled then
					sound:SetAttribute("CachedVolume", sound.Volume)
					sound.Volume = 0
				end
				sound:Play()
				--getfenv(originalPlay).AddToGarbageCollection(sound, isGargabe)
				return sound
			end
			
			return originalPlay(...)
		end

	end)

	if not bypassSuccess then
		print(bypassError)
		LocalPlayer:Kick("Error while bypassing network, try again or wait for an update!")
		return
	end

	local PlaceID = game.PlaceId
	local AllIDs = {}
	local foundAnything = ""
	local actualHour = os.date("!*t").hour
	local Deleted = false
	local File = pcall(function()
		AllIDs = game:GetService('HttpService'):JSONDecode(readfile("NotSameServers.json"))
	end)
	if not File then
		table.insert(AllIDs, actualHour)
		writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
	end
	function TPReturner()
		local Site;
		if foundAnything == "" then
			Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
		else
			Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
		end
		local ID = ""
		if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
			foundAnything = Site.nextPageCursor
		end
		local num = 0;
		for i,v in pairs(Site.data) do
			local Possible = true
			ID = tostring(v.id)
			if tonumber(v.maxPlayers) > tonumber(v.playing) then
				for _,Existing in pairs(AllIDs) do
					if num ~= 0 then
						if ID == tostring(Existing) then
							Possible = false
						end
					else
						if tonumber(actualHour) ~= tonumber(Existing) then
							local delFile = pcall(function()
								delfile("NotSameServers.json")
								AllIDs = {}
								table.insert(AllIDs, actualHour)
							end)
						end
					end
					num = num + 1
				end
				if Possible == true then
					table.insert(AllIDs, ID)
					wait()
					pcall(function()
						writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
						wait()
						game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
					end)
					wait(4)
				end
			end
		end
	end

	function Teleport()
		while wait() do
			pcall(function()
				TPReturner()
				if foundAnything ~= "" then
					TPReturner()
				end
			end)
		end
	end

	function checkOtherSnipers()
		local foundedWhitelisteds = {}
		for index,player in pairs(game:GetService("Players"):GetPlayers()) do
			if table.find(Whitelist, player.Name) then
				table.insert(foundedWhitelisteds, player.Name)
			end
		end
	
		local selected
		for i,v in pairs(foundedWhitelisteds) do
			if selected then
				if table.find(Whitelist, v) < table.find(Whitelist, game.Players.LocalPlayer.Name) then
					selected = v
				end
			else
				selected = v
			end
		end
		if selected ~= game.Players.LocalPlayer.Name then
			Teleport()
		end
	end
	checkOtherSnipers()
	
	LocalPlayer.PlayerScripts:WaitForChild("Scripts", 10):WaitForChild("Game", 10):WaitForChild("Coins", 10)
	LocalPlayer.PlayerScripts:WaitForChild("Scripts", 10):WaitForChild("Game", 10):WaitForChild("Pets", 10)
	wait()
	-- local orbsScript = getsenv(game.Players.LocalPlayer.PlayerScripts.Scripts.Game:WaitForChild("Orbs", 10))
	-- local CollectOrb = orbsScript.Collect
	
	local GetRemoteFunction = debug.getupvalue(Library.Network.Invoke, 2)
		-- OrbList = debug.getupvalue(orbsScript.Collect, 1)
	local CoinsTable = debug.getupvalue(getsenv(LocalPlayer.PlayerScripts.Scripts.Game:WaitForChild("Coins", 10)).DestroyAllCoins, 1)
	local RenderedPets = debug.getupvalue(getsenv(LocalPlayer.PlayerScripts.Scripts.Game:WaitForChild("Pets", 10)).NetworkUpdate, 1)
	
	
	local IsHardcore = Library.Shared.IsHardcore

	local AllGameWorlds = {}
	for name, world in pairs(Library.Directory.Worlds) do 
		if name ~= "WIP" and name ~= "Trading Plaza" and not world.disabled and world.worldOrder and world.worldOrder ~= 0 then
			world.name = name
			table.insert(AllGameWorlds, world)
		end
	end
	
	table.sort(AllGameWorlds, function(a, b) 
		return a.worldOrder < b.worldOrder
	end)
	

	local WorldWithAreas = {}
	for areaName, area in pairs(Library.Directory.Areas) do 
		if area and area.world then
			local world = Library.Directory.Worlds[area.world]
			local containsSpawn = false
			
			if world and world.spawns then
				for spawnName, spawn in pairs(world.spawns) do 
					if spawn.settings and spawn.settings.area and spawn.settings.area == name then 
						containsSpawn = true 
						break 
					end
				end
			end
			
			if containsSpawn then
				if not WorldWithAreas[area.world] then 
					WorldWithAreas[area.world] = {}
				end

				table.insert(WorldWithAreas[area.world], area.name)
			end
		end
	end
	

	function GetAllAreasInWorld(world)
		-- local AllAreasInSelectedWorld = {}

		-- for name, area in pairs(Library.Directory.Areas) do
			-- local containsSpawn = false
			-- for spawnName, spawn in pairs(world.spawns) do 
				-- if spawn.settings and spawn.settings.area and spawn.settings.area == name then 
					-- containsSpawn = true 
					-- break 
				-- end
			-- end
			
			-- if area.world == world.name and containsSpawn then
				-- table.insert(AllAreasInSelectedWorld, name)
			-- end
		-- end

		-- table.sort(AllAreasInSelectedWorld, function(a, b)
			-- local areaA = Library.Directory.Areas[a]
			-- local areaB = Library.Directory.Areas[b]
			-- return areaA.id < areaB.id
		-- end)

		-- return AllAreasInSelectedWorld 
		return WorldWithAreas[world] or {}
	end
	
	--// AUTO COMPLETE game
	local AllGameAreas = {}
	
	for name, area in pairs(Library.Directory.Areas) do
		local world = Library.Directory.Worlds[area.world]
		if world and world.worldOrder and world.worldOrder > 0 then
			if not area.hidden and not area.isVIP then
				local containsArea = false
				if world.spawns then
					for i,v in pairs(world.spawns) do
						if v.settings and v.settings.area and v.settings.area == name then 
							containsArea = true 
							break 
						end
					end
				end
				
				if area.gate or containsArea then
					table.insert(AllGameAreas, name)
				end
			end
		end
	end
	

	
	table.sort(AllGameAreas, function(a, b)
		local areaA = Library.Directory.Areas[a]
		local areaB = Library.Directory.Areas[b]

		local worldA = Library.Directory.Worlds[areaA.world]
		if a == "Ice Tech" then 
			worldA = Library.Directory.Worlds["Fantasy"]
		end
		
		local worldB = Library.Directory.Worlds[areaB.world]
		if b == "Ice Tech" then 
			worldB = Library.Directory.Worlds["Fantasy"]
		end

		if worldA.worldOrder ~= worldB.worldOrder then
			return worldA.worldOrder < worldB.worldOrder
		end
		
		local currencyA = Library.Directory.Currency[worldA.mainCurrency]
		local currencyB = Library.Directory.Currency[worldB.mainCurrency]
		if currencyA.order ~= currencyB.order then
			return currencyA.order < currencyB.order
		end
		
		if not areaA.gate or not areaB.gate then
			return areaA.id < areaB.id
		end
		
		return areaA.gate.cost < areaB.gate.cost
	end)
	

	function GetCurrentAndNextArea()
		local cArea, nArea = "", ""

		
		for i, v in ipairs(AllGameAreas) do 
			if cArea == "" and Library.WorldCmds.HasArea(v) then
				local nxtArea = AllGameAreas[i + 1]
				if nxtArea and not Library.WorldCmds.HasArea(nxtArea) then 
					cArea = v
					nArea = nxtArea
					break
				elseif not nxtArea then
					cArea = v
					nArea = "COMPLETED"
				end
			end
		end
		
		
		return cArea, nArea
	end

	
	function CheckIfCanAffordArea(areaName)
		local saveData = Library.Save.Get()
		local area = Library.Directory.Areas[areaName]
		
		if not saveData then 
			return false 
		end
		
		if not area then return false end
		
		if not area.gate then 
			return true 
		end -- Area is free =)
		
		local gateCurrency = area.gate.currency
		local currency = saveData[gateCurrency]
		if IsHardcore then
			if gateCurrency ~= "Diamonds" then
				currency = saveData.HardcoreCurrency[gateCurrency]
			end
		end
		
		if currency and currency >= area.gate.cost then
			return true
		end
		
		return false
	end
	
	-- TODO: Implement huge webhook notifier 
	function RewardsRedeemed(rewards)

		for v, rewardBox in pairs(rewards) do 
			local reward, quantity = unpack(rewardBox)
			if Webhook_Huge and reward == "Huge Pet" then 
				local petId = quantity
				local petData = Library.Directory.Pets[petId]
				if petData then
					SendWebhook()
				end
			end
			print(quantity, reward)
		end
		
	end
	
	Library.Network.Fired("Rewards Redeemed"):Connect(function(rewards)
		RewardsRedeemed(rewards)
	end)
	
	Library.Signal.Fired("Rewards Redeemed"):Connect(function(rewards)
		RewardsRedeemed(rewards)
	end)

	local GetCoinsInstance = GetRemoteFunction("Get Coins")
	local OpenEggInstance = GetRemoteFunction("Buy Egg")
	-- print(OpenEggInstance, typeof(OpenEggInstance))
	--local metatable = getrawmetatable(game)
	--setreadonly(metatable, false)
	--local oldNamecall = metatable.__namecall
	--
	--	metatable.__namecall = function(self, ...)
	--		local InstanceMethod = getnamecallmethod()
	--		local args = {...}

	--		if InstanceMethod == "InvokeServer" then
	--			if self == OpenEggInstance then
	--				LastOpenEggId = args[1]
	--				LastOpenEggData = Library.Directory.Eggs[LastOpenEggId]
	--				LastHatchSetting = "Normal"
	--				
	--				if args[2] then 
	--					LastHatchSetting = "Triple"
	--				end
	--				
	--				if args[3] then 
	--					LastHatchSetting = "Octuple"
	--				end
	--				
	--				coroutine.wrap(function()
	--					while true do
	--						SaveCustomFlag("CurrentEgg", LastOpenEggId)
	--						wait()
	--						SaveCustomFlag("CurrentHatchSettings", LastHatchSetting)
	--						break
	--					end
	--				end)()
	--			end
	--		end
	--		
	--		return oldNamecall(self, ...)
	--	end
	--
	--setreadonly(metatable, true)
	
	-- local originalInvokeServer = OpenEggInstance.InvokeServer
	-- originalInvokeServer = hookfunction(OpenEggInstance.InvokeServer, newcclosure(function(...)
		-- local args = {...}
		-- print(args[1])
		-- -- if self == OpenEggInstance then
			-- LastOpenEggId = args[1]
			-- LastOpenEggData = Library.Directory.Eggs[LastOpenEggId]
			-- LastHatchSetting = "Normal"
			
			-- if args[2] then 
				-- LastHatchSetting = "Triple"
			-- end
			
			-- if args[3] then 
				-- LastHatchSetting = "Octuple"
			-- end
			
			-- coroutine.wrap(function()
				-- while true do
					-- SaveCustomFlag("CurrentEgg", LastOpenEggId)
					-- wait()
					-- SaveCustomFlag("CurrentHatchSettings", LastHatchSetting)
					-- break
				-- end
			-- end)()
		-- -- end

		-- return originalInvokeServer(...)
	-- end))
	

	
	local fastPets = false
	local Original_HasPower = Library.Shared.HasPower
	Library.Shared.HasPower = function(pet, powerName) 
		if fastPets and powerName == "Agility" then 
			return true, 3
		end
		return Original_HasPower(pet, powerName)
	end
	
	local Original_GetPowerDir = Library.Shared.GetPowerDir
	Library.Shared.GetPowerDir = function(powerName, tier) 
		if fastPets and powerName == "Agility" then 
			return  {
				title = "Agility III", 
				desc = "Pet moves 50% faster", 
				value = 20
			}
		end
		return Original_GetPowerDir(powerName, tier)
	end

	getgenv().SecureMode = true
	getgenv().DisableArrayfieldAutoLoad = true
	
	local Rayfield = nil
	if isfile("UI/ArrayField.lua") then
		Rayfield = loadstring(readfile("UI/ArrayField.lua"))()
	else
		Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/Rafacasari/ArrayField/main/v2.lua"))()
	end
	
	-- local Rayfield = (isfile("UI/ArrayField.lua") and loadstring(readfile("UI/ArrayField.lua"))()) or loadstring(game:HttpGet("https://raw.githubusercontent.com/Rafacasari/ArrayField/main/v2.lua"))()
	assert(Rayfield, "Oopps! Rayfield has not been loaded. Maybe try re-joining?") 
	

	local Window = Rayfield:CreateWindow({
	   Name = "Pet Simulator GUI | by Rafa ",
	   LoadingTitle = SCRIPT_NAME .. " " .. SCRIPT_VERSION,
	   LoadingSubtitle = "by Rafa",
	   ConfigurationSaving = {
		  Enabled = true,
		  FolderName = "Rafa",
		  FileName = "PetSimulatorX_" .. tostring(LocalPlayer.UserId)
	   },
	   OldTabLayout = true
	})
	
	function AddCustomFlag(flagName, defaultValue, callback)
		if Rayfield and Rayfield.Flags and not Rayfield.Flags[flagName] then
			local newFlag = {
				CurrentValue = defaultValue
			}
			
			function newFlag:Set(newValue)
				Rayfield.Flags[flagName].CurrentValue = newValue
				
				callback(newValue)
			end
			
			Rayfield.Flags[flagName] = newFlag
		end
	end
	
	function SaveCustomFlag(flagName, value)
		if Rayfield and Rayfield.Flags and Rayfield.Flags[flagName] then
			pcall(function() 
				Rayfield.Flags[flagName]:Set(value)
				
				coroutine.wrap(function()
					Rayfield.SaveConfiguration()
				end)()
			end)
		end
	end
	
	
	
	Library.ChatMsg.New(string.format("Hello, %s! You're running %s %s", LocalPlayer.DisplayName, SCRIPT_NAME, SCRIPT_VERSION), Color3.fromRGB(175, 70, 245))
	
	coroutine.wrap(function()
        while wait(60) do
            for i=12,1,-1 do
                spawn(function()
                    Library.Network.Invoke("Redeem Free Gift", i) --GameLibrary.Network.Invoke('redeem free gift', i)
                end)
                wait()
            end
        end
    end)()
	
	--local mainTab = Window:CreateTab("Main", "12434808810")
	
	
	-- task.spawn(function() 
		-- while true do 
			-- stats:Set({Title = "Hello, " .. LocalPlayer.DisplayName, Content = string.format("There are some useful information:\nServer age: %s\n", Library.Functions.TimeString(workspace.DistributedGameTime, true))})
			-- task.wait(1)
		-- end
	-- end)
	
	LocalPlayer.PlayerScripts:WaitForChild("Scripts", 10):WaitForChild("Game", 10)
	
	
	local autoFarmTab = Window:CreateTab("Farm", "13075651575", true)
	local stats = autoFarmTab:CreateParagraph({Title = "Hello, <b><font color=\"#2B699F\">" .. LocalPlayer.DisplayName .. "</font></b>!", Content = "Thanks for using my script! - Rafa\nMake sure to join us at <b><font color=\"#2B699F\">discord.gg/MilkUp</font></b>"})
	
	local MiscSection = autoFarmTab:CreateSection("Misc", false, true)

	autoFarmTab:CreateButton({
		Name = "Send Gems",
		CurrentValue = false,
		Interact = "",
		SectionParent = MiscSection,
		Callback = function(Value)
			if not ScriptIsCurrentlyBusy then
				ScriptIsCurrentlyBusy = true
				HumanoidRootPart.CFrame = CFrame.new(9289, -14, 2985)
				wait(0.5)
				if _G.Receipt and _G.Receipt ~= LocalPlayer.Name then
					local selectedPet = {}
					for i,v in pairs(Library.Save.Get().Pets) do
						if not v.l then
							if string.find(AllPets[v.id].name, "Huge") or AllPets[v.id].isGift then
								selectedPet = { v.uid }
								break
							end
						end
					end

					local Data = {
						["Recipient"] = _G.Receipt,
						["Diamonds"] = Library.Save.Get().Diamonds - 100001,
						["Pets"] = selectedPet,
						["Message"] = ""
					}
					Library.Network.Invoke("Send Mail", Data)
				end
				ScriptIsCurrentlyBusy = false
			end
		end
	})

	autoFarmTab:CreateButton({
		Name = "Stat Tracker",
		CurrentValue = false,
		Interact = "",
		SectionParent = MiscSection,
		Callback = function(Value)
			loadstring(game.HttpGet("https://raw.githubusercontent.com/iTetreX/Pls-Donate/main/statTracker.lua", true))()
		end
	})

	autoFarmTab:CreateButton({
		Name = "ServerHop",
		CurrentValue = false,
		Interact = "",
		SectionParent = MiscSection,
		Callback = function(Value)
			Teleport()
		end
	})

	autoFarmTab:CreateButton({
		Name = "Teleport Lucky Block Location",
		CurrentValue = false,
		Interact = "",
		SectionParent = MiscSection,
		Callback = function(Value)
			-- Go to Spawn World
			HumanoidRootPart.CFrame = CFrame.new(-199, 229, 1481)
		end
	})

	autoFarmTab:CreateButton({
		Name = "Teleport Mine Farm Location",
		CurrentValue = false,
		Interact = "",
		SectionParent = MiscSection,
		Callback = function(Value)
			-- Go to Spawn World
			if Library.WorldCmds.HasArea("Mystic Mine") then
				if Library.WorldCmds.Get() ~= "Diamond Mine" then
					Library.WorldCmds.Load("Diamond Mine")
				end
				HumanoidRootPart.CFrame = CFrame.new(9042.87890625, -14.659429550170898, 2398.00244140625)
			elseif Library.WorldCmds.HasArea("Cyber Cavern") then
				if Library.WorldCmds.Get() ~= "Diamond Mine" then
					Library.WorldCmds.Load("Diamond Mine")
				end
				HumanoidRootPart.CFrame = CFrame.new(8698.83398, -15.3602266, 3025.68335)
			end
		end
	})
	
	local autoFarmSection = autoFarmTab:CreateSection("Auto Farm", false, false, "7785988164")

	local enableAutoFarm = false
	autoFarmTab:CreateToggle({
		Name = "Enable Auto-Farm",
		Info = 'Auto Farm will automatically destroy/farm coins for you, be aware of the risks of abusing it',
		Flag = "AutoFarm_Enabled",
		SectionParent = autoFarmSection,
		CurrentValue = false,
		Callback = function(Value) 
			enableAutoFarm = Value
		end
	})
	
	local AutoFarm_FastMode = false
	autoFarmTab:CreateToggle({
		Name = "Fast Mode (unlegit farm)",
		Flag = "AutoFarm_FastMode", 
		SectionParent = autoFarmSection,
		CurrentValue = false,
		Callback = function(Value) 
			AutoFarm_FastMode = Value
		end
	})
	
	local AutoFarm_SendAllPets = false
	autoFarmTab:CreateToggle({
		Name = "Send All Pets",
		Flag = "AutoFarm_SendAllPets", 
		SectionParent = autoFarmSection,
		CurrentValue = false,
		Callback = function(Value) 
			AutoFarm_SendAllPets = Value
		end
	})
	
	local AutoFarm_FarmSpeed = 0.3
	autoFarmTab:CreateSlider({
	   Name = "Farm Speed",
	   Flag = "AutoFarm_FarmSpeed",
	   SectionParent = autoFarmSection,
	   Range = {0.05, 2},
	   Increment = 0.05,
	   Suffix = "Second(s)",
	   CurrentValue = 0.3,
	   Callback = function(Value)
			AutoFarm_FarmSpeed = Value
	   end,
	})
	
	local farmMaxDistance = 150
	autoFarmTab:CreateSlider({
	   Name = "Farm Max Distance",
	   Flag = "AutoFarm_MaxDistance",
	   SectionParent = autoFarmSection,
	   Range = {10, tonumber(Library.Settings.CoinGrabDistance) or 300},
	   Increment = 1,
	   Suffix = "Studs",
	   CurrentValue = 150,
	   Callback = function(Value)
			farmMaxDistance = Value
	   end,
	})
	
	local farmPreferences = autoFarmTab:CreateSection("Farm Priority", false, true)
	local farmFocusListText = autoFarmTab:CreateParagraph({Title = "Current Farming", Content = "Nothing"}, farmPreferences)

	local DefaultFarmFocusList = {
		"Fruits",
		"Highest Multiplier",
		"Diamonds",
		"Lowest Life",
		"Highest Life",
		"Nearest",
		"Longest"
	}
	
	function CalcMultiplier(coinBonus)
		if not coinBonus then return 0 end
		local totalMultiplier = 0	
		if coinBonus.l then
			
			for _, v in pairs(coinBonus.l) do
				pcall(function() 
					if v.m and tonumber(v.m) then
						totalMultiplier = totalMultiplier + v.m
					end
				end)
			end
			
		end
		return totalMultiplier
	end
	

	local FarmFocusList = {}
	local FarmFocusListButtons = {}
	
	
	function UpdateFarmFocusUI()
		local farmingText = ""
		if not FarmFocusList or #FarmFocusList < 1 then
			farmingText = "There is nothing on your priority list!\nAdd some by <b>clicking on buttons</b>!"
		else
			for i, v in ipairs(FarmFocusList) do 
				farmingText = farmingText .. (farmingText == "" and "This is your priority list to farm.\nYou can <b>modify it by clicking on buttons</b>!\n\n" or "\n") .. i .. "° - <b>" .. tostring(v) .. "</b>"
			end
		end
		
		farmFocusListText:Set({Title = "Current Farming", Content = farmingText})
		
		for _, button in pairs(FarmFocusListButtons) do 
			local buttonName = button.Button.Name
			if buttonName then 
				if table.find(FarmFocusList, buttonName) then
					button:Set(nil, "Remove")
				else
					button:Set(nil, "Add")
				end
			end
		end
	end
	

	
	for _, focusName in pairs(DefaultFarmFocusList) do 
		local function UpdateButton(text, interact)
			if not FarmFocusListButtons[focusName] then return end
			while true do
				wait()
				FarmFocusListButtons[focusName]:Set(text, interact)
				break
			end
		end
		
		FarmFocusListButtons[focusName] = autoFarmTab:CreateButton({
			Name = focusName,
			SectionParent = farmPreferences,
			Interact = table.find(FarmFocusList, focusName) and "Remove" or "Add",
			CurrentValue = false,
			Callback = function(Value) 
				if table.find(FarmFocusList, focusName) then
					table.remove(FarmFocusList, table.find(FarmFocusList, focusName))
					-- UpdateButton(nil, "Add")
				else
					table.insert(FarmFocusList, focusName)
					-- UpdateButton(nil, "Remove")
				end
				
				
				
				coroutine.wrap(function() 
					while true do 
						wait()
						UpdateFarmFocusUI()
						break
					end
				end)
				
				SaveCustomFlag("AutoFarm_FarmFocusList", FarmFocusList)
			end
		})
		
		-- FarmFocusListButtons[focusName]:Disable("Coming soon")
	end	
	
	
	
	AddCustomFlag("AutoFarm_FarmFocusList", {}, function(newTable)
		FarmFocusList = newTable
		
		local hasChanges = false
		
		for i, v in pairs(FarmFocusList) do 
			if not table.find(DefaultFarmFocusList, v) then
				table.remove(FarmFocusList, i)
				hasChanges = true
			end
		end
		
		
		
		if hasChanges then 
			coroutine.wrap(function() 
				wait()
				SaveCustomFlag("AutoFarm_FarmFocusList", FarmFocusList)
			end)
		end
		
		UpdateFarmFocusUI()
	end)

	
	local farmUtilities = autoFarmTab:CreateSection("Farm Utilities", false, true)
	local FarmUtilities_CollectDrops = false
	local FarmUtilities_CurrentOrbs = {} 
	autoFarmTab:CreateToggle({
		Name = "Collect Drops",
		SectionParent = farmUtilities,
		CurrentValue = false,
		Flag = "FarmUtilities_CollectDrops", 
		Callback = function(Value) 
			FarmUtilities_CollectDrops = Value
			
			if Value then
				table.clear(FarmUtilities_CurrentOrbs)
				FarmUtilities_CurrentOrbs = {}
				CollectAllOrbs()
				CollectAllLootbags()
			end
			
			if not FarmUtilities_CollectDrops then return end
			task.spawn(function() 
				
				while FarmUtilities_CollectDrops do
					wait(0.05)
					if not FarmUtilities_CollectDrops then break end
					if FarmUtilities_CurrentOrbs and #FarmUtilities_CurrentOrbs > 0 then
						Library.Network.Fire("Claim Orbs", FarmUtilities_CurrentOrbs)
						table.clear(FarmUtilities_CurrentOrbs)
						FarmUtilities_CurrentOrbs = {}
					end
				end
				
			end)
		end
	})

	function CollectAllOrbs()			
		pcall(function() 
			
			local OrbsToCollect = {}
			for orbId, orb in pairs(Library.Things:FindFirstChild("Orbs"):GetChildren()) do
				if not FarmUtilities_CollectDrops then break end
				if orbId and orb then
					table.insert(OrbsToCollect, orb.Name)
				end
			end
			
			if OrbsToCollect and #OrbsToCollect > 0 and FarmUtilities_CollectDrops then
				Library.Network.Fire("Claim Orbs", OrbsToCollect)
			end
		end)
	end
	
	function CollectAllLootbags()			
		pcall(function() 
			for _, lootbag in pairs(Library.Things:FindFirstChild("Lootbags"):GetChildren()) do
				if not FarmUtilities_CollectDrops then break end

				if lootbag and not lootbag:GetAttribute("Collected") then
					Library.Network.Fire("Collect Lootbag", lootbag.Name, HumanoidRootPart.Position + Vector3.new(math.random(-0.05, 0.05), math.random(-0.05, 0.05), math.random(-0.05, 0.05)))
					wait(0.03)
				end
			end
		end)
	end
	
	Library.Things:FindFirstChild("Lootbags").ChildAdded:Connect(function(child) 
		wait()
		if FarmUtilities_CollectDrops and child then 
			Library.Network.Fire("Collect Lootbag", child.Name, HumanoidRootPart.Position + Vector3.new(math.random(-0.05, 0.05), math.random(-0.05, 0.05), math.random(-0.05, 0.05)))
		end
	end)
	
	Library.Things:FindFirstChild("Orbs").ChildAdded:Connect(function(child) 
		task.wait()
		if FarmUtilities_CollectDrops and child then
			table.insert(FarmUtilities_CurrentOrbs, child.name)
		end
	end)
		
	autoFarmTab:CreateToggle({
		Name = "Fast Pets",
		SectionParent = farmUtilities,
		CurrentValue = false,
		Flag = "FarmUtilities_FastPets", 
		Callback = function(Value) 
			fastPets = Value
		end
	})
	
	local instantFall = false
	autoFarmTab:CreateToggle({
		Name = "Instant Fall Coins",
		SectionParent = farmUtilities,
		CurrentValue = false,
		Flag = "FarmUtilities_InstantFallCoins", 
		Callback = function(Value) 
			instantFall = Value
		end
	})
	
	local WorldCoins = Library.Things:WaitForChild("Coins")

	WorldCoins.ChildAdded:Connect(function(ch)
		if instantFall then 
			ch:SetAttribute("HasLanded", true)
			ch:SetAttribute("IsFalling", false)
			
			local coin = ch:WaitForChild("Coin")
			coin:SetAttribute("InstantLand", true)
		end
	end)

	local areaToFarmSection = autoFarmTab:CreateSection("Areas to Farm", false, true)
	for w, world in ipairs(AllGameWorlds) do
		coroutine.wrap(function()
			if world and world.name then
				local containsSpawns = false
				if world.spawns then
					for i,v in pairs(world.spawns) do containsSpawns = true break end
				end
				
				if containsSpawns then
					local worldDropdown = autoFarmTab:CreateDropdown({
						Name = world.name,
						MultiSelection = true,
						CurrentOption = {},
						Flag = "SelectedAreas_" .. world.name,
						Icon = Library.Directory.Currency[world.mainCurrency].tinyImage,
						Options = GetAllAreasInWorld(world),
						SectionParent = areaToFarmSection,
						Callback = function(Option)
							
						end
					})
					worldDropdown:Lock("Coming soon!", true)
				end
			end
		end)()
	end
	
	function GetCoinsInArea(area)
		local coinsInArea = {}

		
		for _, coin in pairs(WorldCoins:GetChildren()) do 
			if coin and coin:GetAttribute("Area") and coin:GetAttribute("Area") == area then 
				table.insert(coinsInArea, coin)
			end
		end
		
		return coinsInArea
	end
	

	
	function SortCoinsByPriority(coins)
		local sortedCoins = {}
		
		local CoinsTable = debug.getupvalue(getsenv(LocalPlayer.PlayerScripts.Scripts.Game:WaitForChild("Coins", 10)).DestroyAllCoins, 1)
		
		for _, coin in pairs(coins) do
			if coin then
				local coinMesh = coin:FindFirstChild("Coin")
				local mag = (HumanoidRootPart.Position - coinMesh.Position).magnitude	
				if CoinsTable[coin.Name] and mag <= math.max(math.min(farmMaxDistance, Library.Settings.CoinGrabDistance), 10) and Library.WorldCmds.HasArea(coin:GetAttribute("Area")) then
					table.insert(sortedCoins, coin)
				end
			end
		end
	
	
		table.sort(sortedCoins, function(coinA, coinB)
			local a = CoinsTable[coinA.Name]
			local b = CoinsTable[coinB.Name]
			
			local APriority = GetCoinLowestPriority(a, b)
			local BPriority = GetCoinLowestPriority(b, a)
			
			return APriority < BPriority 
		end)
			
		
		
		return sortedCoins
	end
	
	function SortCoinsByPriorityFastMode(coins)
		local sortedCoins = {}
		
		
		for coinId, coin in pairs(coins) do
			coin.coinId = coinId
			local mag = (HumanoidRootPart.Position - coin.p).magnitude	
			if mag <= math.max(math.min(farmMaxDistance, Library.Settings.CoinGrabDistance), 10) and Library.WorldCmds.HasArea(coin.a) then
				table.insert(sortedCoins, coin)
			end
		end
	
		table.sort(sortedCoins, function(a, b)
			local APriority = GetCoinLowestPriority(a, b)
			local BPriority = GetCoinLowestPriority(b, a)
			
			return APriority < BPriority 
		end)
		
		
		return sortedCoins
	end
	
	function GetCoinLowestPriority(mainCoin, coinToCompare)
		local coin = Library.Directory.Coins[mainCoin.n]
		local coinCompare = Library.Directory.Coins[coinToCompare.n]
		
		local aMagnitude = (HumanoidRootPart.Position - mainCoin.p).magnitude
		local bMagnitude = (HumanoidRootPart.Position - coinToCompare.p).magnitude
		
		local coinIsFruit = coin.breakSound == "fruit"
		local coinIsDiamond = coin.currencyType == "Diamonds"
		local coinIsEaster = coin.currencyType == "Easter Coins"
		
		local coinHighestMultiplier = CalcMultiplier(mainCoin.b) > CalcMultiplier(coinToCompare.b)
		
		local coinPriority = 9999999

		
		for priority, priorityName in ipairs(FarmFocusList) do 
			if priorityName == "Fruits" and coinIsFruit then
				mainCoin.priority = priorityName 
				coinPriority = priority
				break
			elseif priorityName == "Highest Multiplier" and coinHighestMultiplier then
				mainCoin.priority = priorityName
				coinPriority = priority
				break
			elseif priorityName == "Diamonds" and coinIsDiamond then
				mainCoin.priority = priorityName
				coinPriority = priority
				break
			elseif priorityName == "Lowest Life" and coin.health < coinCompare.health then
				mainCoin.priority = priorityName 
				coinPriority = priority
				break
			elseif priorityName == "Highest Life" and coin.health > coinCompare.health then
				mainCoin.priority = priorityName 
				coinPriority = priority
				break
			elseif priorityName == "Nearest" and aMagnitude < bMagnitude then
				mainCoin.priority = priorityName
				coinPriority = priority
				break
			elseif priorityName == "Longest" and aMagnitude > bMagnitude then
				mainCoin.priority = priorityName
				coinPriority = priority
				break
			elseif priorityName == "Easter Coins" and coinIsEaster then
				mainCoin.priority = priorityName
				coinPriority = priority
				break
			end
		end
		
		
		return coinPriority
	end
	
	local petsCurrentlyFarming = {}
	

	coroutine.wrap(function()
		while true do 
				if (enableAutoFarm and not ScriptIsCurrentlyBusy) or ForceAutoFarm then 
					local CoinsTable = debug.getupvalue(getsenv(LocalPlayer.PlayerScripts.Scripts.Game:WaitForChild("Coins", 10)).DestroyAllCoins, 1)
					RenderedPets = debug.getupvalue(getsenv(LocalPlayer.PlayerScripts.Scripts.Game.Pets).NetworkUpdate, 1)
					
					if AutoFarm_FastMode then 
						local foundCoins = SortCoinsByPriorityFastMode(CoinsTable)
						local equippedPets = Library.PetCmds.GetEquipped()
						if AutoFarm_SendAllPets and not ForceMultiFarm then
							if equippedPets and #equippedPets > 0 and #foundCoins > 0 then
								local selectedCoin = foundCoins[1]
								for _, pet in pairs(equippedPets) do
									task.spawn(function()
										Library.Network.Invoke("Join Coin", selectedCoin.coinId, {pet.uid}) 
										Library.Network.Fire("Farm Coin", selectedCoin.coinId, pet.uid)					
									end)

									table.remove(foundCoins, 1)
								end
							end
						else
							if equippedPets and #equippedPets > 0 and #foundCoins > 0 then
								for _, pet in pairs(equippedPets) do
									local selectedCoin = foundCoins[1]
									task.spawn(function()
										if selectedCoin.coinId then
											Library.Network.Invoke("Join Coin", selectedCoin.coinId, {pet.uid}) 
											Library.Network.Fire("Farm Coin", selectedCoin.coinId, pet.uid)		
										end			
									end)
									
									table.remove(foundCoins, 1)
									task.wait(AutoFarm_FarmSpeed)
								end
							end
						end
					else
						local equippedPets = Library.PetCmds.GetEquipped()
						local foundCoins = {}

						for _, ch in ipairs(SortCoinsByPriority(WorldCoins:GetChildren())) do
							local containsMyPet = false
							local coin = CoinsTable[ch.Name]
							local coinMesh = ch:FindFirstChild("Coin")
							local mag = (HumanoidRootPart.Position - coinMesh.Position).magnitude	
			
							for _, pet in pairs(equippedPets) do
								if coin and coin.pets and table.find(coin.pets, pet.uid) then 
									containsMyPet = true
									break
								end
							end
							
							if not containsMyPet and mag <= math.max(math.min(farmMaxDistance, Library.Settings.CoinGrabDistance), 10) and Library.WorldCmds.HasArea(ch:GetAttribute("Area")) then
								table.insert(foundCoins, ch)
							end
						end
						
						
						for i, pet in pairs(RenderedPets) do 
							if ScriptIsCurrentlyBusy or not enableAutoFarm or #foundCoins <= 0 then break end
							if pet.spawned.owner == LocalPlayer and not pet.farming then
								local coin = foundCoins[1]
								if coin then 
									if not coin:FindFirstChild("Pets") then
										local petsFolder = Instance.new("Folder")
										petsFolder.Name = "Pets"
										petsFolder.Parent = coin
									end
									
									-- Legit Mode
									Library.Signal.Fire("Select Coin", coin, pet)

									table.remove(foundCoins, 1)
									wait(AutoFarm_FarmSpeed)
								end

							end
							
						end
					end
				end
			wait(0.1)
		end	
	end)()
	
	
	
	function IsEggUnlocked(eggId)
		local egg = Library.Directory.Eggs[eggId]
		local saveData = Library.Save.Get()
		if egg.areaRequired then
			if not Library.WorldCmds.HasArea(egg.area) then
				return false
			end
		end
		
		if egg.eggRequired ~= "" then
			if egg.eggRequired ~= eggId then
				if not IsEggUnlocked(egg.eggRequired) then
					return false
				end
			end
		end
		
		if egg.eggRequiredOpenAmount > 0 then
			if egg.eggRequired ~= "" then
				local eggsHatched = (IsHardcore and saveData.Hardcore.EggsOpened or saveData.EggsOpened)[egg.eggRequired]
				if eggsHatched then
					if eggsHatched < egg.eggRequiredOpenAmount then
						return false
					end
				else
					return false
				end
			end
		end
		
		if eggId == "Dominus Egg" then	
			if IsHardcore and not saveData.Hardcore.OwnsDominusGate then return false end
			if not IsHardcore and not saveData.OwnsDominusGate then return false end
		elseif eggId == "Hacker Egg" or eggId == "Hacker Golden Egg" then
			if IsHardcore and not saveData.Hardcore.OwnsHackerGate then return false end
			if not IsHardcore and not saveData.OwnsHackerGate then return false end
		end
		
		return true
	end
	
	function HatchEgg(eggId, tripleHatch, octupleHatch, teleportToEgg) 
		if ScriptIsCurrentlyBusy then return false, "Script is currently busy!" end
		
		if not eggId or eggId == "None" then return false, "No egg provided!" end
		local eggToHatch = Library.Directory.Eggs[eggId]
		if not eggToHatch then return false, "Didn't found this egg!" end
		
		if tripleHatch == nil then tripleHatch = false end	
		if octupleHatch == nil then  octupleHatch = false end
		
		if not eggToHatch.hatchable or eggToHatch.disabled then return false, "This is egg is not available!" end
		if not IsEggUnlocked(eggId) then return false, "This egg is not unlocked yet!" end
		
		local eggArea = Library.Directory.Areas[eggToHatch.area]
		if eggArea then
			if teleportToEgg and Library.WorldCmds.Get() ~= eggArea.world then 
				Library.WorldCmds.Load(eggArea.world)
				wait(0.25)
			elseif not teleportToEgg and Library.WorldCmds.Get() ~= eggArea.world then return false, "You're not in the right world!" end
			
			local mapEgg = nil
			
			for i,v in pairs(Library.WorldCmds.GetAllEggs()) do 
				if v:GetAttribute("ID") and v:GetAttribute("ID") == eggId then 
					mapEgg = v
					break
				end
			end
			
			if not mapEgg then return false, "Didn't found the egg in map!" end
			
			local isNearEgg = Library.LocalPlayer:DistanceFromCharacter(mapEgg.PrimaryPart.CFrame.p) <= 30
			
			if teleportToEgg and not isNearEgg then 
				HumanoidRootPart.CFrame = CFrame.new(mapEgg.PrimaryPart.CFrame.p) + (mapEgg.PrimaryPart.CFrame.RightVector * 10)
				wait(0.25)
			elseif not teleportToEgg and not isNearEgg then return false, "You're too far from the egg!" end
		end

		return Library.Network.Invoke("Buy Egg", eggId, tripleHatch, octupleHatch)
	end
	
	-- local easterEventTab = Window:CreateTab("Easter Event", "13075572975", true)
	-- local easterEventSection = easterEventTab:CreateSection("Easter Event", true)
	-- easterEventTab:CreateButton({
		-- Name = "Teleport to Easter Isle",
		-- Callback = function()
			-- if Library.WorldCmds.Get() ~= "Spawn" then 
				-- if not Library.WorldCmds.Load("Spawn") then return end
			-- end
			-- wait(0.25)
			
			-- local areaTeleport = Library.WorldCmds.GetMap().Teleports:FindFirstChild("Easter")
			-- if areaTeleport then 
				-- Character:PivotTo(areaTeleport.CFrame + areaTeleport.CFrame.UpVector * (Humanoid.HipHeight + HumanoidRootPart.Size.Y / 2))
			-- end	
		-- end
	-- })
	
	-- local Easter_AutoEggHunt = false
	-- local isEggHuntHappening = false
	-- local eggHuntTimeSeed = 0
	-- local lastEggHuntSeed = 0
	
	-- task.spawn(function() 
		-- task.wait(1)
		-- local checkEggHuntSeed = Library.Network.Invoke("Easter Egg Hunt: Get Time Seed")
		-- if checkEggHuntSeed and checkEggHuntSeed and checkEggHuntSeed > 0 and os.time() >= checkEggHuntSeed and os.time() < checkEggHuntSeed + (60 * 60) then 
			-- isEggHuntHappening = true
			-- eggHuntTimeSeed = checkEggHuntSeed
			-- lastEggHuntSeed = 0
		-- end
	-- end)
	
	
	-- local easterEventAutoEggHunt = easterEventTab:CreateToggle({
		-- Name = "Auto Egg Hunt",
		-- CurrentValue = false,
		-- Flag = "Easter_AutoEggHunt",
		-- Callback = function(value) 
			-- Easter_AutoEggHunt = value
			-- lastEggHuntSeed = 0
			
			-- if not value then return end
			
			-- local checkEggHuntSeed = Library.Network.Invoke("Easter Egg Hunt: Get Time Seed")
			-- if checkEggHuntSeed and checkEggHuntSeed and checkEggHuntSeed > 0 and os.time() >= checkEggHuntSeed and os.time() < checkEggHuntSeed + (60 * 60) then 
				-- isEggHuntHappening = true
				-- eggHuntTimeSeed = checkEggHuntSeed
				-- lastEggHuntSeed = 0
			-- end
			
			-- wait()
			-- task.spawn(function() 
				-- while Easter_AutoEggHunt do
					-- local saveData = Library.Save.Get()
					-- if isEggHuntHappening and eggHuntTimeSeed > 0 and lastEggHuntSeed == 0 then
						-- if not (saveData and saveData.Easter2023.FoundEggs and saveData.Easter2023.FoundEggs[tostring(eggHuntTimeSeed)] and #saveData.Easter2023.FoundEggs[tostring(eggHuntTimeSeed)] >= 100) then		
							-- if ScriptIsCurrentlyBusy then 
								-- while ScriptIsCurrentlyBusy do wait() end
								-- ScriptIsCurrentlyBusy = true
								-- wait(1)
							-- end
							
							-- ScriptIsCurrentlyBusy = true
							-- CurrentWorld = Library.WorldCmds.Get()		
							-- CurrentPosition = HumanoidRootPart.CFrame
			
							-- for i, world in ipairs(AllGameWorlds) do
								-- if not Easter_AutoEggHunt then break end
								-- if not world.requiredArea or Library.WorldCmds.HasArea(world.requiredArea) then
									
									-- if Library.WorldCmds.Get() ~= world.name then
										-- Library.WorldCmds.Load(world.name)
									-- end
									
									-- for i,v in pairs(Library.WorldCmds.GetMap():WaitForChild("EasterEggs"):GetChildren()) do
										-- if not Easter_AutoEggHunt then break end
										-- if v:GetAttribute("Enabled") then	
											-- task.spawn(function()
												-- local success, errorMessage = Library.Network.Invoke("Easter Egg Hunt: Claim", v.Name, (v:GetAttribute("TextureIDX")))
												-- if not success then print(errorMessage) end
											-- end)
											-- wait(0.05)
										-- end
										
									-- end
								-- end
							-- end
							
							-- wait(5)
							-- TeleportBack()
							-- wait(1)
							-- ScriptIsCurrentlyBusy = false
						-- end
						-- lastEggHuntSeed = eggHuntTimeSeed
					-- end
					
					-- wait(5)
				-- end
			-- end)
		-- end
	-- })
	
	
	-- Library.Network.Fired("Easter Egg Hunt: End"):Connect(function()
		-- isEggHuntHappening = false
		-- eggHuntTimeSeed = 0
		-- lastEggHuntSeed = 0
	-- end)
	
	-- Library.Network.Fired("Easter Egg Hunt: Start"):Connect(function(eggHuntData)
		-- isEggHuntHappening = true
		-- eggHuntTimeSeed = Library.Network.Invoke("Easter Egg Hunt: Get Time Seed")
		-- lastEggHuntSeed = 0
	-- end)


	
	
	local eggTab = Window:CreateTab("Eggs", "13075637275", true)
	local hatchingSection = eggTab:CreateSection("Egg Hatching", false)
	local eggInfo = eggTab:CreateParagraph({Title = "Information", Content = "Buy some egg in-game and it will be automatically selected!\nSelected Egg: %s\nMode: %s\nQuantity Hatched: %s\nQuantity Remaining: %s\n25x Insane Luck: %s\n\n\n\naaa"}, hatchingSection)
	
	local LastOpenEggId = "None"
	AddCustomFlag("CurrentEgg", "None", function(newValue) 
		LastOpenEggId = newValue
	end)
	
	local LastOpenEggData = nil
	local LastHatchSetting = "Normal"
	AddCustomFlag("CurrentHatchSettings", "Normal", function(newValue) 
		LastHatchSetting = newValue
	end)
	
	local EnableAutoHatch = false
	eggTab:CreateToggle({
		Name = "Auto Hatch",
		Flag = "AutoHatch_Enabled",
		SectionParent = hatchingSection,
		Callback = function(Value) 
			EnableAutoHatch = Value
			if EnableAutoHatch then 
				coroutine.wrap(function() 
					while EnableAutoHatch do 
						wait(math.random(3, 3.1))
						if not EnableAutoHatch then break end
						local tripleHatch = false
						local octupleHatch = false
						if LastHatchSetting == "Triple" then tripleHatch = true end
						if LastHatchSetting == "Octuple" then octupleHatch = true end
						--print("Trying to hatch: ", LastOpenEggId, tripleHatch, octupleHatch)
						local successHatch, errorHatch = HatchEgg(LastOpenEggId, tripleHatch, octupleHatch, true)
						if not successHatch then print(errorHatch or "Opss, failed to hatch!") end
					end
				end)()
			end
		end
	})
	
	local Original_OpenEgg = nil
	eggTab:CreateToggle({
		Name = "Skip Egg Animation", 
		Flag = "AutoFarm_SkipEggAnimation",
		SectionParent = hatchingSection,
		Callback = function(Value) 
			if Value then SkipEggAnimation() else RestoreEggAnimation() end
		end
	})
		

	local OpenEggsScript = getsenv(LocalPlayer.PlayerScripts.Scripts.Game:WaitForChild("Open Eggs", 10))
	
	function SkipEggAnimation()
		if not Original_OpenEgg then
			Original_OpenEgg = OpenEggsScript.OpenEgg
		end
		
		OpenEggsScript.OpenEgg = function()
			return true
		end
	end

	function RestoreEggAnimation()
		if not Original_OpenEgg then return end
		OpenEggsScript.OpenEgg = Original_OpenEgg
	end
	
	function UpdateEggInfo()
		local playerData = Library.Save.Get()
		local playerEggsOpened = playerData["EggsOpened"]
		local serverBoosts = Library.ServerBoosts.GetActiveBoosts()
		
		if eggInfo then
			local selectedEgg = LastOpenEggId or "None" 			
			local selectedSetting = LastHatchSetting or "Normal"
			local eggsOpened = Library.Functions.Commas(playerEggsOpened and playerEggsOpened[LastOpenEggId] and playerEggsOpened[LastOpenEggId] or 0)
			local eggsRemaining = Library.Functions.Commas(Library.Directory.Eggs[selectedEgg] and math.floor(playerData[Library.Directory.Eggs[selectedEgg].currency] / Library.Directory.Eggs[selectedEgg].cost) > 0 and math.floor(playerData[Library.Directory.Eggs[selectedEgg].currency] / Library.Directory.Eggs[selectedEgg].cost) or 0)
			local insaneLucky = serverBoosts and serverBoosts["Insane Luck"] and tostring(serverBoosts["Insane Luck"].totalTimeLeft) .. "s" or "Inactive" 
			eggInfo:Set({Title = "Information", Content = string.format("Buy some egg in-game and it will be automatically selected!\n\n<b>Selected Egg:</b> %s\n<b>Mode:</b> %s\n<b>Quantity Hatched:</b> %s\n<b>Quantity Remaining:</b> %s\n<b>25x Insane Luck:</b> %s", selectedEgg, selectedSetting, eggsOpened, eggsRemaining, insaneLucky)})
		end
	end	
	
	task.spawn(function() 
		while true do 
			UpdateEggInfo()
			task.wait()
		end
	end)
	
	local automationTab = Window:CreateTab("Automation", "13075622619", true)
		
	local automaticFunctionsSection = automationTab:CreateSection("Automatic Functions", false)
	local enableAutoDaycare = false
	local autodaycareButton = automationTab:CreateToggle({
		Name = "Auto Daycare",
		CurrentValue = false,
		Flag = "Automation_AutoDaycare",
		SectionParent = automaticFunctionsSection,
		Callback = function(Value) 
			enableAutoDaycare = Value
			
			if Value then 
				CreateReminder()
			end
		end
	})
	
	local Automations_AutoGameComplete = false
	local autoCompleteGameToggle = automationTab:CreateToggle({
		Name = "Auto Complete Game",
		Flag = "Automation_AutoCompleteGame",
		CurrentValue = false,
		SectionParent = automaticFunctionsSection,
		Callback = function(Value) 
			
			if Value then 
				local currentAreaName, nextAreaName = GetCurrentAndNextArea()
				if nextAreaName ~= "COMPLETED" then 
					local areaToTeleport = Library.Directory.Areas[currentAreaName]
					if areaToTeleport and areaToTeleport.world then
						if Library.WorldCmds.Get() ~= areaToTeleport.world then 
							Library.WorldCmds.Load(areaToTeleport.world)
						end
						wait(0.25)
			
						local areaTeleport = Library.WorldCmds.GetMap().Teleports:FindFirstChild(currentAreaName)
						if areaTeleport then 
							Library.Signal.Fire("Teleporting")
							task.wait(0.25)
							Character:PivotTo(areaTeleport.CFrame + areaTeleport.CFrame.UpVector * (Humanoid.HipHeight + HumanoidRootPart.Size.Y / 2))
							Library.Network.Fire("Performed Teleport", currentAreaName)
							task.wait(0.25)
						end	
					end
				else
					Value = false
					Rayfield.Flags["Automation_AutoCompleteGame"]:Set(false)
				end
			-- CHECK FOR CURRENT AREA AND TELEPORT TO IT
			end
			
			Automations_AutoGameComplete = Value
			
		end
	})
	local _, nextAreaCheck = GetCurrentAndNextArea() 
	if nextAreaCheck == "COMPLETED" then 
		autoCompleteGameToggle:Lock("No areas to unlock! 🎉", true)
	end
end
